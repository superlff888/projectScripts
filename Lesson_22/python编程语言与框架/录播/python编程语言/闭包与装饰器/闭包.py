# @Time  : 2021/07/01 18:46
# @Author    : ╰☆H.俠ゞ
# -*-coding=utf-8-*-
# =============================================================

def stu_grade(grade: int):
    grad = '2'
    print(f"外函数的年纪：{grad}")

    # 闭包无法修改外部函数stu_grade的局部变量，即装饰器中的原函数；需要加unlocal才可以
    def output_stu_info(name: str, gender: int):
        grad = '1'  # 只是定义了与外部函数一样的同名函数而已；可以使用外部函数的局部变量，但是不能修改
        print(f"内函数的年纪：{grad}")
        # print(f"新生名字{name},性别{gender},年级{grade}")

    return output_stu_info


stu_gradeInfo = stu_grade(1)
# 内函数只是创建了一个同名变量
stu_gradeInfo('夏明', 16)  # '3'
stu_gradeInfo('李宁', 18)  # '3'
stu_gradeInfo('Jordan', 12)  # '3'
# 外函数再次被调用，仍然是外部函数定义的变量值
stu_grade(1)  # '2'

# ================================================================================================================
print("================================================================================================================")
# ================================================================================================================
"""
在普通函数中，虽然可以直接使用全局变量，但是不可以直接修改全局变量。从变量的作用域来说，一旦你尝试修改全局变量，那么就会尝试创建并使用一个同名的局部
变量。因此，如果你需要在普通函数中修改全局变量，需要使用global
"""
a = 100


def func1():
    # 直接使用全局变量，可以
    print("(直接使用全局变量)func1:", a)


def func2():
    # 直接修改全局变量，不可以
    # 该代码会创建同名的局部变量
    a = 200
    print("func2:", a)


def func3():
    global a
    a = 300
    print("func3:", a)


func1()

# 执行完func2，全局的a的值不会被改变
func2()
print(f'全局的a的值{a}')

# 执行func3，全局的a的值发生了改变
func3()
print(f'func3方法体中，将局部变量转变为全局变量（global a），此时方法内的a即是全局变量a ，因此全局的a的值被修改为：{a}')

# ================================================================================================================
print("================================================================================================================")
# ================================================================================================================
"""
同样的，如果你希望通过定义在内部的函数去修改其外部函数的变量，那么必须使用nonlocal
"""


def func1():
    a = 100

    def func1_inner():
        a = 200

    func1_inner()
    print("func1:", a)  # 此时a仍然为100，不会被修改


def func2():
    a = 100

    def func2_inner( ):
        nonlocal a
        a = 200

    func2_inner()
    print("func2:", a)  # 此时a已经被修改为了200


func1()
func2()

