# @Time  : 2021/05/28 09:19
# @Author    : House Lee
# -*-coding=utf-8-*-
"""
【重点】
1、记住：'入参'指向'返回' !!!
2、定义的内嵌函数要被返回（函数对象的引用，即内存地址）
3、'入参'指向'返回'后，会执行'返回'；此处的’返回‘要求一定是可被调用对象，不可以是”None,str”等不可被调用的对象
4、原函数作为入参的装饰器或装饰器内嵌函数是'自驱'调用并执行；'返回'函数调用的原理是：执行原函数的指向函数，即
  原来的同名函数会指向了新的函数（装饰器函数或装饰器内嵌函数的返回结果），于是
                                                  调用now()将执行新函数wrapper！
                                                  调用now()将执行新函数wrapper！
                                                  调用now()将执行新函数wrapper！
5、'返回'函数是“伪执行”func()，它执行的新'返回'函数wrapper！同时接收被装饰函数的参数; 闭包与装饰器“最内层嵌套函数”的返回
   才是真正的返回原函数或原函数的执行结果
6、被装饰的函数，即原函数要在装饰器内嵌函数中执行
  【特殊名词解析】
    '入参': 将原函数作为参数传入装饰器或装饰器内嵌函数，该参数即是原函数 func；
    '返回'： '入参'函数执行后的返回值

【编写装饰器的三个步骤】
1、定义一个外函数，给外函数定义一个参数，用来接收被装饰函数对象
2、定义一个内函数，内函数内调用传入的函数（装饰器为高阶函数，要在最内层嵌套函数中调用传入的函数）
    -- 在内函数内实现装饰器逻辑
3、定义外函数的返回值，该返回值就是下一级内函数对象
"""


import functools

from Lesson_22.python编程语言与框架.录播.python编程语言.闭包与装饰器.decorator调用位置 import logging, logg

"""
【重要】
    在执行原函数前，先执行装饰器函数！
    在执行原函数前，先执行装饰器函数！
    在执行原函数前，先执行装饰器函数！

"""

"""
必须要返回func函数名（代表内存地址）

"""
print("开始debug")


# def logging(func):  # 定义一个参数func，用来接收自动传过来的原函数对象
#     print(f'the time of {func.__name__} is coming!')
#     return func

@logg  # 装饰器的调用顺序，从上到下
@logging  # 如果装饰器在另外一个模块中，导入装饰器即可
def study(t=2):
    if t == 'a':
        print("该学习了")
    else:
        print("再睡会")


# print(id(study))
study()
"""
【代码运行分析】
1、"有借有还" : Python的@语法,原来的同名函数会指向了新的函数（装饰器函数或装饰器内嵌函数的返回结果），即
2、调用原函数,会先执行装饰器函数,装饰器函数一般会把原函数作为自己的参数，且最终返回原函数
3、study = logging(study) 执行装饰器函数后，返回原函数func（此时的func是study）的内存地址,并指向原函数study，study()执行的是装饰
  器返回的函数。
    【注意】若返回的func()，即返回的是study()函数执行的结果None，则无法调用原函数 ，因为 ：None()是个啥？？？！！！
4、被装饰的函数，即原函数要在装饰器内嵌函数中执行
"""

# ===================================================================================================================
print("\n===========================================================================================================")
print("===========================================================================================================\n")


# ===================================================================================================================


# 函数需要调用才执行 ，格式：func()
def log(func):
    # 代码块中所有的func都是参数，包括内嵌函数、print
    print(f'此时函数为： {func.__name__} ,其id为：{id(func)}')  # func是原函数，即now

    # 用不定长参数，接收N个参数
    # '入参'指向'返回' !!!
    def wrapper(*args, **kw):  # 【重点】同名的now变量指向了新的函数,now()的变量也要被接收,且应接收被装饰函数的所有参数
        print(f'\n此函数非彼函数,此时{now.__name__}函数的id为：{id(now)}')  # 同名的now变量指向了新的函数（见‘执行顺序解析’）
        print(f'\n原函数 {func.__name__}函数 的id为：{id(func)}')  # 同名的now变量指向了新的函数（见‘执行顺序解析’）
        return func(*args, **kw)  # func原函数; 函数名中的参数，一定要在函数代码块中体现出来，*args, **kw

    print("\n校验点")
    return wrapper  # 此时还不能返回wrapper(),因为其代表返回函数执行后的结果，


@log
def now(param, a, b):
    print(f'\n {param}{a}{b}打印原函数 2021-5-28')


# print(f'\n经过decorator装饰之后的函数，它们的__name__为：{now.__name__}\n')
# 执行完装饰器函数，即now = log(now)后，执行下面的代码
'''
由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数wrapper，相当于同名now变量被赋
值装饰器的返回值，于是调用now()将执行新函数wrapper()，即在log()函数中返回的wrapper()函数。
    【注意】原函数仍然存在！！！
'''

now("lee", 1, 2)
# print(f'\n经过decorator装饰之后的函数，它们的__name__为：{now.__name__}\n ->装饰器内最后返回的可执行装饰器内部函数（func对装饰器而言只是个参数）')

"""
【执行顺序解析】
    1、用表达式“now()”执行启动对函数now()的调用; log是一个装饰器，根据Python的@语法，调用原函数前，先执行装饰器函数log(原函数func,下简称"func")
    2、调用装饰器函数log(func)，Python的@语法，首先会将函数名now函数名作为参数传递给装饰器函数log(func)，执行后，打印"\n校验点"且返回wrapper函
      数（内存地址）；原来的now()函数仍然存在，只是同名的now变量指向了新的函数名wrapper,于是执行调用wrapper(*args, **kw)
    3、执行调用'装饰器函数log'的"内嵌函数"wrapper(),打印指向的新函数名wrapper及id,同时打印原函数名func及id,并且返回func(*args, **kw)的执行
        结果（即返回原函数并获得原函数的执行结果）
        【注意】原函数now()仅在装饰器的内嵌函数中执行了一次
 
【小结】
    1、Python的装饰器@语法，把decorator置于函数的定义处
    2、装饰器函数若无参数，则应将原函数作为入参传给装饰器函数；若装饰器函数本身需要传入参数，那就需要编写一个返回decorator的高阶函数
"""

# ========================================================================================================================
print(
    "\n===================================================================================================================")

"""
如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：
 now = log('execute')(now)
"""


# =============================================================================================================================


def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print(f'\n3、装饰器参数为：{text}; 原函数为：{func.__name__}')
            print(f'\n3、该内嵌函数为：{wrapper.__name__}')
            print(f"4、返回并再调用返回的函数原始函数func，即{func}")
            return func
        print(f"\n2、返回并执行{now.__name__}")
        return wrapper
    print(f"\n1、执行调用log('execute')后，now重新指向函数{now.__name__},所以会再调用返回的函数{now.__name__}")
    print(f"\n1、执行调用log('execute')后，函数{decorator.__name__}")
    return decorator


@log('execute')
def now():
    print('\n5、date is 2015-3-25')


r = now()
r()
"""
【关键】  -- > now变量指向了新的函数 !!!!!!!!!!!!!!!!!!
1、【这是装饰器的特性,当成公式记住！！！】
    将原函数func作为入参的函数为节点，嵌套的效果是这样的：now = log('execute')(now),这是装饰器的特性。也就是说，在调用原函数now()本身前，先
    执行log('execute')(now)，返回函数wrapper，此时原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数wrapper，于是调用now()将执
    行新函数wrapper(*args, **kw)，执行新函数后，返回原函数func的内存地址
    
2、我们来剖析上面的语句，具体是这样的：
    首先执行log('execute')，返回的是decorator函数内存地址，再调用返回的decorator函数，参数是now原函数，执行decorator的返回值是wrapper函数；
    观察函数decorator(func)就会发现，该函数传入func原函数名作为参数，返回wrapper函数，此时同名now变量指向了
    新的函数wrapper，因此可以总结一个定理："有借有还，指向定理"，借指的是将原函数作为入参传给decorator(func)，还指的是返回下一级
    内层嵌套函数，指向即是原now变量指向了返回的内嵌函数，即函数wrapper；于是调用now()将执行新函数wrapper(*args, **kw)，最终返回原
    函数func（内存地址），当然也可以返回原函数的执行结果
【总结】
1、首先，调用原函数now()前，先执行装饰器，即log('execute')(func),此时的func为原函数now
2、同名的now变量不会指向log函数和decorator函数，func所在的函数decorator执行后才返回wrapper，记住：'返回'指向'入参' !!!

"""

# ======================================================================================================================================
print("\n======================================================================================================================")
# =============================================================================================================================

"""
因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，即复制到'返回'函数中（出处：'入参'指向'返回' !!!）,
否则，有些依赖函数签名的代码执行就会出错。不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的
"""


def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        """
        wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用
        :param args:
        :param kw:
        :return:
        """
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper


@log
def study_(t=2):
    if t == 'a':
        print("该学习了")
    else:
        print(f"{study_.__name__}")


if __name__ == '__main__':
    study_()
