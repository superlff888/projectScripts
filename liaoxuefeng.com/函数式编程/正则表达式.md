# 正则表达式

### 【预定义字符集匹配：用于匹配到 1个字符】 1个！1个！！1个！！！
    
    \d  匹配一个数字； 1个！1个！！1个！！！；等价于[0-9]
    \D  匹配任意一个非数字字符，等价于[^0-9]或[^\d]
    \w  匹配一个数字或字母或下划线,等价于[a-zA-Z0-9_]
    \W  匹配一个非数字或非字母或非下划线,等价于[^a-zA-Z0-9_]或[^\w],要注意的是[]里面的‘^’表示取反
    \s  匹配任何一个空白字符，等价于[<空格>\t\n\r\f\v]
    \S  匹配任何一个非空字符，等级于[^\s]
      
### 【单个字符匹配：一个中括号‘[]’匹配一个字符】1个！1个！！1个！！！
    .    匹配任意一个字符
    […]  表示字符类，字符类可以逐个列出，也可以给出一个范围，[a-zA-Z0-9_,]或者[asdfghjkl]或者[12345678]
    [^…] 表示除指定的字符类，匹配指定字符类之外的任意一个字符，a[1-3bcd]可以匹配a0,aa,a9,等等
    \    表示转义，可用来改变特殊字符（包括\本身）的原有含义，a\[abcd\]\.eF可以匹配的字符串 a[abcd].eF

### 【字符匹配次数 --量词: 用于限制匹配字符的长度，作用于该符号[前面]的单个字符】
     *     表示匹配‘前面的那一个字符’任意次（包括0次）,等同于于{0,}
                示例一、‘py*’或‘py{0,}’能匹配到‘p’（匹配0次‘y’），也能匹配到‘py’（匹配1次‘y’）
                示例二、现有字符串‘abcd’，表达式：bd*,其含义为不管d取到0次还是多次，前面一定是‘b’，在字符串中‘b’相邻的后面找不到‘d’，‘bd*’最后的取值结果为‘b’
     +     表示匹配‘前面的那一个字符’至少一次 （即1次或多次)，等同于{1,}
            例如：‘ab+c’能匹配到‘abc’（匹配1次‘b’），也能匹配到‘abbc’（匹配2次‘b’），但是不能匹配到‘ac’（因为至少要匹配1次‘b’）
     ?     表示匹配‘前面的那一个字符’0个或者1个字符，例如：ab?c 只能匹配 ac或 abc; a(.+?)b 可从“ba123ba678b”匹配到["123","678"]，
            若正则表达式为 a(.+)b，则匹配到["a123ba678b"]; 所以?作用是找a和b间最少字符数，即**`a和b最近距离间的字符`**，起到止贪作用 
    {n}    表示n个字符
    {n,m}  表示n-m个字符; n <= 字符数 <= m
    注意：{m,n}中的m和n可以省略其中一个，{,n}相当于{0,n}，{m,}相当于{m,整数最大值}
        ? 这个字符在正则表达中与 ?, +, *, {m,n}连用时还有一个额外的功能，就是将匹配模式由贪婪模式（尽可能的增加匹配字符个数） 变成 
        非贪婪模式（尽可能减少匹配字符个数）
### 【边界匹配】
    ^  匹配字符串的开头，在多行模式中匹配每一行的行首，表示匹配以指定字符开头的字符串，‘^abc.*’ 可匹配 abc 或 abcd
    $  匹配字符串的末尾，在多行模式中匹配每一行的行尾，表示匹配以指定字符结尾的字符串，‘.*abc$’ 可匹配 abc 或 123abc

### 【分组】
    将小括号内的字符作为一组。
    例如 "name":"lee521",可以用表达式 (.+?):"(.+?)" 
    例如 a(.+?)b 可从“ba123ba678ba11111111b”匹配到["123","678","11111111"]
    解析：(1)".+" 指的是匹配a和b之间任意一个或多个字符,a和b间夹住的字符个数可以是任意个数，默认贪婪模式(a和b间出现的字符越多越好),匹配结果肯定
            只有一个，即匹配结果为['123ba678ba11111111']
         (2)".+?" 指的是匹配a和b之间任意一个或多个字符，a和b间夹住的字符个数可以是任意个数，表达式中加上“?”,就停止贪婪,以最小单位匹配a和b之间的
            任意个数字符，即["123","678","11111111"]

